# kerberos.cnf
# kerberos conformation file
# Copyright 2008 Anders Broman 
# $Id$

#.EXPORTS
Checksum
PrincipalName
KerberosTime
Realm
#.FIELD_RENAME
EncryptedData/etype encryptedData_etype
KDC-REQ-BODY/etype kDC-REQ-BODY_etype

#.FN_BODY KDC-REQ/msg-type VAL_PTR = &msgtype
guint32 msgtype;

%(DEFAULT_BODY)s
	if (do_col_info & check_col(actx->pinfo->cinfo, COL_INFO)) {
		col_add_str(actx->pinfo->cinfo, COL_INFO,
			val_to_str(msgtype, krb5_msg_types,
			"Unknown msg type %%#x"));
	}
	do_col_info=FALSE;

	/* append the application type to the tree */
	proto_item_append_text(tree, " %%s", val_to_str(msgtype, krb5_msg_types, "Unknown:0x%%x"));

#.FN_BODY Int32 VAL_PTR = actx->value_ptr
%(DEFAULT_BODY)s

#.FN_BODY PA-DATA/padata-type
/* Calling Int32 returns the value in ctx->value_ptr */
actx->value_ptr = &krb_PA_DATA_type;
%(DEFAULT_BODY)s

krb_PA_DATA_type&=0xff; /*this is really just one single byte */
	if(tree){
		proto_item_append_text(tree, " %%s",
			val_to_str(krb_PA_DATA_type, krb5_preauthentication_types,
			"Unknown:%%d"));
	}

#.FN_BODY PA-DATA/padata-value
proto_tree *sub_tree=tree;

	if(actx->created_item){
		sub_tree=proto_item_add_subtree(actx->created_item, ett_kerberos_PA_DATA);
	}

	switch(krb_PA_DATA_type){
	case KRB5_PA_TGS_REQ:
		offset=dissect_ber_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_kerberos_Applications);
 		break;
	case KRB5_PA_PK_AS_REQ:
		offset=dissect_ber_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_pkinit_PaPkAsReq);
 		break;
 	case KRB5_PA_PK_AS_REP:
		offset=dissect_ber_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_pkinit_PaPkAsRep);
 		break;
		/*
	case KRB5_PA_PAC_REQUEST:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PA_PAC_REQUEST);
		break;
	case KRB5_PA_S4U2SELF:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PA_S4U2SELF);
 		break;
	case KRB5_PA_PROV_SRV_LOCATION:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PA_PROV_SRV_LOCATION);
 		break;
 		*/
	case KRB5_PA_ENC_TIMESTAMP:
		offset=dissect_ber_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_kerberos_PA_ENC_TIMESTAMP);
 		break;
 		/*
	case KRB5_PA_ENCTYPE_INFO:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PA_ENCTYPE_INFO);
 		break;
	case KRB5_PA_ENCTYPE_INFO2:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PA_ENCTYPE_INFO2);
 		break;
	case KRB5_PA_PW_SALT:
		offset=dissect_ber_old_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, dissect_krb5_PW_SALT);
 		break;
	*/
	default:
		offset=dissect_ber_octet_string_wcb(FALSE, actx, sub_tree, tvb, offset,hf_kerberos_padata_value, NULL);
	}
/*qqq*/


#.TYPE_ATTR
KDC-REQ/msg-type  TYPE = FT_UINT32  DISPLAY = BASE_DEC  STRINGS = VALS(krb5_msg_types)
# this does not work for some reason :(
EncryptedData/etype  TYPE = FT_UINT32  DISPLAY = BASE_DEC  STRINGS = VALS(krb5_encryption_types)



