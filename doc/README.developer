$Id: README.developer,v 1.26 2001/04/10 07:21:38 guy Exp $

This file is a HOWTO for Ethereal developers. It describes how to start coding
a Ethereal protocol dissector and the use some of the important functions and
variables.

The file is target at creating dissectors based upon tvbuffers.  All 
new dissector should be written with tvbuffers not with the old style, pd packet
data pointer, dissectors.  The tvbuffer dissectors improve the handling of short
packets. See the README.tvbuff for more details on tvbuffers.


1. Setting up your protocol dissector code.

This section provides skeleton code for a protocol dissector. It also explains
the basic functions needed to enter values in the traffic summary columns,
add to the protocol tree, and work with registered header fields.

1.1 Code style.

1.1.1 Comments.

Don't use C++-style comments (comments beginning with "//" and running to the
end of the line); Ethereal's dissectors are written in C, and thus run through C
rather than C++ compilers, and not all C compilers support C++-style comments
(GCC does, but IBM's C compiler for AIX, for example, doesn't do so by default).

1.1.2 Name convention.

Ethereal uses the underscore_convention rather than the InterCapConvention for
function names, so new code should probably use underscores rather than
intercaps for functions and variable names. This is especially important if you
are writing code that will be called from outside your code.  We are just
trying to keep thing consistent for other users.

1.2 Skeleton code.

Ethereal requires certain things when setting up a protocol dissector. 
Below is skeleton code for a dissector that you can copy to a file and
fill in.  Your dissector should follow the naming convention of packet-
followed by the abbreviated name for the protocol.  It is recommended
that where possible you keep to the IANA abbreviated name for the
protocol, if there is one, or a commonly-used abbreviation for the
protocol, if any.

Dissectors that use the dissector registration to tell a lower level
dissector don't need to define a prototype in the .h file. For other
dissectors the main dissector routine should have a prototype in a header
file whose name is "packet-", followed by the abbreviated name for the
protocol, followed by ".h"; any dissector file that calls your dissector
should be changed to include that file.

You may not need to include all the headers listed in the skeleton
below, and you may need to include additional headers.  For example, the
code inside

	#ifdef NEED_SNPRINTF_H

		...

	#endif

is needed only if you are using the "snprintf()" function.

The "$Id: README.developer,v 1.26 2001/04/10 07:21:38 guy Exp $"
in the comment will be updated by CVS when the file is
checked in; it will allow the RCS "ident" command to report which
version of the file is currently checked out.

------------------------------------Cut here------------------------------------
/* packet-PROTOABBREV.c
 * Routines for PROTONAME dissection
 * Copyright 2000, YOUR_NAME <YOUR_EMAIL_ADDRESS>
 *
 * $Id: README.developer,v 1.26 2001/04/10 07:21:38 guy Exp $
 *
 * Ethereal - Network traffic analyzer
 * By Gerald Combs <gerald@unicom.net>
 * Copyright 1998 Gerald Combs
 *
 * Copied from WHATEVER_FILE_YOU_USED
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif

#ifdef HAVE_NETINET_IN_H
# include <netinet/in.h>
#endif

#include <glib.h>

#ifdef NEED_SNPRINTF_H
# include "snprintf.h"
#endif

#include "packet.h"
#include "packet-PROTOABBREV.h"

/* Initialize the protocol and registered fields */
static int proto_PROTOABBREV = -1;
static int hf_PROTOABBREV_FIELDABBREV = -1;

/* Initialize the subtree pointers */
static gint ett_PROTOABBREV = -1;

/* Code to actually dissect the packets */
static void
dissect_PROTOABBREV(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{

/* Set up structures needed to add the protocol subtree and manage it */
	proto_item *ti;
	proto_tree *PROTOABBREV_tree;

/* Make entries in Protocol column and Info column on summary display */
	if (check_col(pinfo->fd, COL_PROTOCOL)) 
		col_set_str(pinfo->fd, COL_PROTOCOL, "PROTOABBREV");
    
/* This field shows up as the "Info" column in the display; you should make
   it, if possible, summarize what's in the packet, so that a user looking
   at the list of packets can tell what type of packet it is. See section 1.5
   for more information.

   If you are setting it to a constant string, use "col_set_str()", as
   it's more efficient than the other "col_set_XXX()" calls.

   If you're setting it to a string you've constructed, or will be
   appending to the column later, use "col_add_str()".

   "col_add_fstr()" can be used instead of "col_add_str()"; it takes
   "printf()"-like arguments.  Don't use "col_add_fstr()" with a format
   string of "%s" - just use "col_add_str()" or "col_set_str()", as it's
   more efficient than "col_add_fstr()".

   If you will be fetching any data from the packet before filling in
   the Info column, clear that column first, in case the calls to fetch
   data from the packet throw an exception because they're fetching data
   past the end of the packet, so that the Info column doesn't have data
   left over from the previous dissector; do

	if (check_col(pinfo->fd, COL_INFO)) 
		col_clear(pinfo->fd, COL_INFO);

   */

	if (check_col(pinfo->fd, COL_INFO)) 
		col_set_str(pinfo->fd, COL_INFO, "XXX Request");

/* In the interest of speed, if "tree" is NULL, don't do any work not
   necessary to generate protocol tree items. */
	if (tree) {

/* NOTE: The offset and length values in the call to
   "proto_tree_add_item()" define what data bytes to highlight in the hex
   display window when the line in the protocol tree display
   corresponding to that item is selected.

   tvb_length(tvb) is a handy way to highlight all data from the offset to
   the end of the packet. */

/* create display subtree for the protocol */
		ti = proto_tree_add_item(tree, proto_PROTOABBREV, tvb, 0, tvb_length(tvb), FALSE);

		PROTOABBREV_tree = proto_item_add_subtree(ti, ett_PROTOABBREV);

/* add an item to the subtree, see section 1.6 for more information */
		proto_tree_add_uint(tree, hf_PROTOABBREV_FIELDABBREV, tvb, offset, len, value)


/* Continue adding tree items to process the packet here */


	}

/* If this protocol has a sub-dissector call it here, see section 1.8 */
}


/* Register the protocol with Ethereal */

/* this format is require because a script is used to build the C function
   that calls all the protocol registration.
*/

void
proto_register_PROTOABBREV(void)
{                 

/* Setup list of header fields  See Section 1.6.1 for details*/
	static hf_register_info hf[] = {
		{ &hf_PROTOABBREV_FIELDABBREV,
			{ "FIELDNAME",           "PROTOABBREV.FIELDABBREV",
			FIELDTYPE, FIELDBASE, FIELDCONVERT, BITMASK,          
			"FIELDDESCR" }
		},
	};

/* Setup protocol subtree array */
	static gint *ett[] = {
		&ett_PROTOABBREV,
	};

/* Register the protocol name and description */
	proto_PROTOABBREV = proto_register_protocol("PROTONAME",
	    "PROTOSHORTNAME", "PROTOABBREV");

/* Required function calls to register the header fields and subtrees used */
	proto_register_field_array(proto_PROTOABBREV, hf, array_length(hf));
	proto_register_subtree_array(ett, array_length(ett));
}


/* If this dissector uses sub-dissector registration add a registration routine.
   This format is required because a script is used to find these routines and
   create the code that calls these routines.
*/
void
proto_reg_handoff_PROTOABBREV(void)
{
	dissector_add("PARENT_SUBFIELD", ID_VALUE, dissect_PROTOABBREV,
	    proto_PROTOABBREV);
}

------------------------------------Cut here------------------------------------

1.3 Explanation of needed substitutions in code skeleton.

In the above code block the following strings should be substituted with
your information.

YOUR_NAME	Your name, of course.  You do want credit, don't you?
		It's the only payment you will receive....
YOUR_EMAIL_ADDRESS	Keep those cards and letters coming.
WHATEVER_FILE_YOU_USED	Add this line if you are using another file as a
		starting point.
PROTONAME	The name of the protocol.
PROTOABBREV	An abbreviated name for the protocol. (NO SPACES) (rec. 
		a-z, 0-9 only and try to conform with IANA names)
FIELDNAME	The displayed name for the header field.
FIELDABBREV	The abbreviated name for the header field. (NO SPACES)
FIELDTYPE	FT_NONE, FT_BOOLEAN, FT_UINT8, FT_UINT16, FT_UINT24,
		FT_UINT32, FT_INT8, FT_INT16, FT_INT24, FT_INT32,
		FT_DOUBLE, FT_ABSOLUTE_TIME, FT_RELATIVE_TIME, FT_STRING,
		FT_STRINGZ, FT_UINT_STRING, FT_ETHER, FT_BYTES, FT_IPv4,
		FT_IPv6, FT_IPXNET
FIELDBASE	BASE_NONE, BASE_DEC, BASE_HEX, BASE_OCT, BASE_BIN
FIELDCONVERT	VALS(x), TFS(x), NULL
BITMASK		Usually 0x0 unless using the TFS(x) field conversion.
FIELDDESCR	A brief description of the field.
PARENT_SUBFIELD	Lower level protocol field used for lookup, i.e. "tcp.port"
ID_VALUE	Lower level protocol field value that identifies this protocol
		For example the TCP or UDP port number


1.4 The dissector and the data it receives.


1.4.1 Header file.

This is only needed if the dissector doesn't use self-registration to
register itself with the lower level dissector.

The dissector has the following header that must be placed into
packet-PROTOABBREV.h.

void
dissect_PROTOABBREV(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);


1.4.2 Extracting data from packets.

NOTE: See the README.tvbuff for more details

The "tvb" argument to a dissector points to a buffer containing the raw
data for the frame. A tvbuffer is a opaque data structure, the internal
data structures are hidden and the data must be access via the tvbuffer
accessors.

The accessors are:

Single-byte accessor:

guint8  tvb_get_guint8(tvbuff_t*, gint offset);

Network-to-host-order access for shorts (guint16), longs (guint24), and
24-bit ints:

guint16 tvb_get_ntohs(tvbuff_t*, gint offset);
guint32 tvb_get_ntohl(tvbuff_t*, gint offset);
guint32 tvb_get_ntoh24(tvbuff_t*, gint offset);

Little-Endian-to-host-order access for shorts (guint16), longs (guint24), and
24-bit ints:

guint16 tvb_get_letohs(tvbuff_t*, gint offset);
guint32 tvb_get_letohl(tvbuff_t*, gint offset);
guint32 tvb_get_letoh24(tvbuff_t*, gint offset);

Copying memory:
guint8* tvb_memcpy(tvbuff_t*, guint8* target, gint offset, gint length);
guint8* tvb_memdup(tvbuff_t*, gint offset, gint length);


Pointer-retrieval:
/* WARNING! This function is possibly expensive, temporarily allocating
 * another copy of the packet data. Furthermore, it's dangerous because once
 * this pointer is given to the user, there's no guarantee that the user will
 * honor the 'length' and not overstep the boundaries of the buffer.
 */ 
guint8* tvb_get_ptr(tvbuff_t*, gint offset, gint length);

The reason that tvb_get_ptr() have to allocate a copy of its data only
occurs with TVBUFF_COMPOSITES, data that spans multiple tvbuffers. If the
user request a pointer to a range of bytes that spans the member tvbuffs that
make up the TVBUFF_COMPOSITE, the data will have to be copied to another
memory region to assure that all the bytes are contiguous.



1.5 Functions to handle columns in the traffic summary window.

The topmost pane of the main window is a list of the packets in the
capture, possibly filtered by a display filter.

Each line corresponds to a packet, and has one or more columns, as
configured by the user.

Many of the columns are handled by code outside individual dissectors;
most dissectors need only specify the value to put in the "Protocol" and
"Info" columns.

Columns are specified by COL_ values; the COL_ value for the "Protocol"
field, typically giving an abbreviated name for the protocol (but not
the all-lower-case abbreviation used elsewhere) is COL_PROTOCOL, and the
COL_ value for the "Info" field, giving a summary of the contents of the
packet for that protocol, is COL_INFO. 

A value for a column should only be added if the user specified that it
be displayed; to check whether a given column is to be displayed, call
'col_info' with the COL_ value for that field as an argument - it will
return TRUE if the column is to be displayed and FALSE if it is not to
be displayed.

The value for a column can be specified with one of several functions,
all of which take the 'fd' argument to the dissector as their first
argument, and the COL_ value for the column as their second argument.

1.5.1 The col_set_str function.

'col_set_str' takes a string as its third argument, and sets the value
for the column to that value.  It assumes that the pointer passed to it
points to a string constant or a static "const" array, not to a
variable, as it doesn't copy the string, it merely saves the pointer
value; the argument can itself be a variable, as long as it always
points to a string constant or a static "const" array.

It is more efficient than 'col_add_str' or 'col_add_fstr'; however, if
the dissector will be using 'col_append_str' or 'col_append_fstr" to
append more information to the column, the string will have to be copied
anyway, so it's best to use 'col_add_str' rather than 'col_set_str' in
that case.

For example, to set the "Protocol" column
to "PROTOABBREV":

	if (check_col(pinfo->fd, COL_PROTOCOL)) 
		col_set_str(pinfo->fd, COL_PROTOCOL, "PROTOABBREV");


1.5.2 The col_add_str function.

'col_add_str' takes a string as its third argument, and sets the value
for the column to that value.  It takes the same arguments as
'col_set_str', but copies the string, so that if the string is, for
example, an automatic variable that won't remain in scope when the
dissector returns, it's safe to use.


1.5.3 The col_add_fstr function.

'col_add_fstr' takes a 'printf'-style format string as its third
argument, and 'printf'-style arguments corresponding to '%' format
items in that string as its subsequent arguments.  For example, to set
the "Info" field to "<XXX> request, <N> bytes", where "reqtype" is a
string containing the type of the request in the packet and "n" is an
unsigned integer containing the number of bytes in the request:

	if (check_col(pinfo->fd, COL_INFO)) 
		col_add_fstr(pinfo->fd, COL_INFO, "%s request, %u bytes",
		    reqtype, n);

Don't use 'col_add_fstr' with a format argument of just "%s" -
'col_add_str', or possibly even 'col_set_str' if the string that matches
the "%s" is a static constant string, will do the same job more
efficiently.


1.5.4 The col_clear function.

If the Info column will be filled with information from the packet, that
means that some data will be fetched from the packet before the Info
column is filled in.  If the packet is so small that the data in
question cannot be fetched, the routines to fetch the data will throw an
exception (see the comment at the beginning about tvbuffers improving
the handling of short packets - the tvbuffers keep track of how much
data is in the packet, and throw an exception on an attempt to fetch
data past the end of the packet, so that the dissector won't process
bogus data), causing the Info column not to be filled in.

This means that the Info column will have data for the previous
protocol, which would be confusing if, for example, the Protocol column
had data for this protocol.

Therefore, before a dissector fetches any data whatsoever from the
packet (unless it's a heuristic dissector fetching data to determine
whether the packet is one that it should dissect, in which case it
should check, before fetching the data, whether there's any data to
fetch; if there isn't, it should return FALSE), it should set the
Protocol column and the Info column.

If the Protocol column will ultimately be set to, for example, a value
containing a protocol version number, with the version number being a
field in the packet, the dissector should, before fetching the version
number field or any other field from the packet, set it to a value
without a version number, using 'col_set_str', and should later set it
to a value with the version number after it's fetched the version
number.

If the Info column will ultimately be set to a value containing
information from the packet, the dissector should, before fetching any
fields from the packet, clear the column using 'col_clear' (which is
more efficient than clearing it by calling 'col_set_str' or
'col_add_str' with a null string), and should later set it to the real
string after it's fetched the data to use when doing that.


1.5.5 The col_append_str function.

Sometimes the value of a column, especially the "Info" column, can't be
conveniently constructed at a single point in the dissection process;
for example, it might contain small bits of information from many of the
fields in the packet.  'col_append_str' takes, as arguments, the same
arguments as 'col_add_str', but the string is appended to the end of the
current value for the column, rather than replacing the value for that
column.  (Note that no blank separates the appended string from the
string to which it is appended; if you want a blank there, you must add
it yourself as part of the string being appended.)


1.5.6 The col_append_fstr function.

'col_append_fstr' is to 'col_add_fstr' as 'col_append_str' is to
'col_add_str' - it takes, as arguments, the same arguments as
'col_add_fstr', but the formatted string is appended to the end of the
current value for the column, rather than replacing the value for that
column.


1.6 Constructing the protocol tree.

The middle pane of the main window, and the topmost pane of a packet
popup window, are constructed from the "protocol tree" for a packet.

The protocol tree, or proto_tree, is a GNode, the N-way tree structure
available within GLIB. Of course the protocol dissectors don't care
what a proto_tree really is; they just pass the proto_tree pointer as an
argument to the routines which allow them to add items and new branches
to the tree.

When a packet is selected in the packet-list pane, or a packet popup
window is created, a new logical protocol tree (proto_tree) is created. 
The pointer to the proto_tree (in this case, 'protocol tree'), is passed
to the top-level protocol dissector, and then to all subsequent protocol
dissectors for that packet, and then the GUI tree is drawn via
proto_tree_draw().

The logical proto_tree needs to know detailed information about the
protocols and fields about which information will be collected from the
dissection routines. By strictly defining (or "typing") the data that can
be attached to a proto tree, searching and filtering becomes possible.
This means that the for every protocol and field (which I also call
"header fields", since they are fields in the protocol headers) which
might be attached to a tree, some information is needed.

Every dissector routine will need to register its protocols and fields
with the central protocol routines (in proto.c). At first I thought I
might keep all the protocol and field information about all the
dissectors in one file, but decentralization seemed like a better idea.
That one file would have gotten very large; one small change would have
required a re-compilation of the entire file. Also, by allowing
registration of protocols and fields at run-time, loadable modules of
protocol dissectors (perhaps even user-supplied) is feasible.

To do this, each protocol should have a register routine, which will be
called when Ethereal starts.  The code to call the register routines is
generated automatically; to arrange that a protocol's register routine
be called at startup:

	the file containing a dissector's "register" routine must be
	added to "DISSECTOR_SOURCES" in "Makefile.am";
 
	the "register" routine must have a name of the form
	"proto_register_XXX";
  
	the "register" routine must take no argument, and return no
	value;
 
	the "register" routine's name must appear in the source file
	either at the beginning of the line, or preceded only by "void "
	at the beginning of the line (that'd typically be the
	definition) - other white space shouldn't cause a problem, e.g.:
 
void proto_register_XXX(void) {
 
	...
 
}
 
and
 
void
proto_register_XXX( void )
{
 
	...
 
}
 
	and so on should work.

For every protocol or field that a dissector wants to register, a variable of
type int needs to be used to keep track of the protocol. The IDs are
needed for establishing parent/child relationships between protocols and
fields, as well as associating data with a particular field so that it
can be stored in the logical tree and displayed in the GUI protocol
tree.

Some dissectors will need to create branches within their tree to help
organize header fields. These branches should be registered as header
fields. Only true protocols should be registered as protocols. This is
so that a display filter user interface knows how to distinguish
protocols from fields.

A protocol is registered with the name of the protocol and its
abbreviation.

Here is how the frame "protocol" is registered.

	int proto_frame;

        proto_frame = proto_register_protocol (
                /* name */            "Frame",
                /* short name */      "Frame",
                /* abbrev */          "frame" );

A header field is also registered with its name and abbreviation, but
information about the its data type is needed. It helps to look at
the header_field_info struct to see what information is expected:

struct header_field_info {
	char				*name;
	char				*abbrev;
	enum ftenum			type;
	int				display;
	void				*strings;
	guint				bitmask;
	char				*blurb;

	int				id;	  /* calculated */
	int				parent;
	int				bitshift; /* calculated */
};

name
----
A string representing the name of the field. This is the name
that will appear in the graphical protocol tree.

abbrev
------
A string with an abbreviation of the field. We concatenate the
abbreviation of the parent protocol with an abbreviation for the field,
using a period as a separator. For example, the "src" field in an IP packet
would have "ip.addr" as an abbreviation. It is acceptable to have
multiple levels of periods if, for example, you have fields in your
protocol that are then subdivided into subfields. For example, TRMAC
has multiple error fields, so the abbreviations follow this pattern:
"trmac.errors.iso", "trmac.errors.noniso", etc.

The abbreviation is the identifier used in a display filter.

type
----
The type of value this field holds. The current field types are:

	FT_NONE			No field type. Used for protocol labels.
	FT_BOOLEAN		0 means "false", any other value means
				"true".
	FT_UINT8		An 8-bit unsigned integer.
	FT_UINT16		A 16-bit unsigned integer.
	FT_UINT24		A 24-bit unsigned integer.
	FT_UINT32		A 32-bit unsigned integer.
	FT_INT8			An 8-bit signed integer.
	FT_INT16		A 16-bit signed integer.
	FT_INT24		A 24-bit signed integer.
	FT_INT32		A 32-bit signed integer.
	FT_DOUBLE		A floating point number.
	FT_ABSOLUTE_TIME	Seconds (4 bytes) and microseconds (4 bytes)
				of time displayed as month name, month day,
				year, hours, minutes, and seconds with 4
				digits after the decimal point.
	FT_RELATIVE_TIME	Seconds (4 bytes) and microseconds (4 bytes)
				of time displayed as seconds and 6 digits
				after the decimal point.
	FT_STRING		A string of characters.
	FT_STRINGZ		A NUL-terminated string of characters.
	FT_UINT_STRING		A counted string of characters, consisting
				of a count (represented as an integral
				value) followed immediately by the
				specified number of characters.
	FT_ETHER		A six octet string displayed in
				Ethernet-address format.
	FT_BYTES		A string of bytes.
	FT_IPv4			A version 4 IP address (4 bytes) displayed
				in dotted-quad IP address format (4
				decimal numbers separated by dots).
	FT_IPv6			A version 6 IP address (16 bytes) displayed
				in standard IPv6 address format.
	FT_IPXNET		An IPX address displayed in hex as a 6-byte
				network number followed by a 6-byte station
				address. 
	FT_TEXT_ONLY		A reserved, non-filterable type for
				converting old style trees. You shouldn't
				be using this.

Some of these field types are still not handled in the display filter
routines, but the most common ones are. The FT_UINT* variables all
represent unsigned integers, and the FT_INT* variables all represent
signed integers; the number on the end represent how many bits are used
to represent the number.

display
-------
The display field has a couple of overloaded uses. This is unfortunate,
but since we're C as an application programming language, this sometimes
makes for cleaner programs. Right now I still think that overloading
this variable was okay.

For integer fields (FT_UINT* and FT_INT*), this variable represents the
base in which you would like the value displayed.  The acceptable bases
are:

	BASE_DEC,
	BASE_HEX,
	BASE_OCT,
	BASE_BIN

For FT_BOOLEAN fields that are also bitfields, 'display' is used to tell
the proto_tree how wide the parent bitfield is.  With integers this is
not needed since the type of integer itself (FT_UINT8, FT_UINT16,
FT_UINT24, FT_UINT32, etc.) tells the proto_tree how wide the parent
bitfield is.

Additionally, BASE_NONE is used for 'display' as a NULL-value. That is,
for non-integers and non-bitfield FT_BOOLEANs, you'll want to use BASE_NONE
in the 'display' field.

It is possible that in the future we will record the endianness of
integers. If so, it is likely that we'll use a bitmask on the display field
so that integers would be represented as BEND|BASE_DEC or LEND|BASE_HEX.
But that has not happened yet.

strings
-------
Some integer fields, of type FT_UINT*, need labels to represent the true
value of a field.  You could think of those fields as having an
enumerated data type, rather than an integral data type.

A 'value_string' structure is a way to map values to strings. 

	typedef struct _value_string {
		guint32  value;
		gchar   *strptr;
	} value_string;

For fields of that type, you would declare an array of "value_string"s:

	static const value_string valstringname[] = {
		{ INTVAL1, "Descriptive String 1" }, 
		{ INTVAL2, "Descriptive String 2" }, 
		{ 0,       NULL },
	};

(the last entry in the array must have a NULL 'strptr' value, to
indicate the end of the array).  The 'strings' field would be set to
'VALS(valstringname)'.

(Note: before Ethereal 0.7.6, we had separate field types like
FT_VALS_UINT8 which denoted the use of value_strings.  Now, the
non-NULLness of the pointer lets the proto_tree know that a value_string
is meant for this field).

If the field has a numeric rather than an enumerated type, the 'strings'
field would be set to NULL.

FT_BOOLEANS have a default map of 0 = "False", 1 (or anything else) = "True".
Sometimes it is useful to change the labels for boolean values (e.g.,
to "Yes"/"No", "Fast"/"Slow", etc.).  For these mappings, a struct called
true_false_string is used. (This struct is new as of Ethereal 0.7.6).

	typedef struct true_false_string {
		char	*true_string;
		char	*false_string;
	} true_false_string;

For Boolean fields for which "False" and "True" aren't the desired
labels, you would declare a "true_false_string"s:

	static const true_false_string boolstringname = {
		"String for True",
		"String for False"
	};

Its two fields are pointers to the string representing truth, and the
string representing falsehood.  For FT_BOOLEAN fields that need a
'true_false_string' struct, the 'strings' field would be set to
'TFS(&boolstringname)'. 

If the Boolean field is to be displayed as "False" or "True", the
'strings' field would be set to NULL.

bitmask
-------
If the field is a bitfield, then the bitmask is the mask which will
leave only the bits needed to make the field when ANDed with a value.
The proto_tree routines will calculate 'bitshift' automatically
from 'bitmask', by finding the rightmost set bit in the bitmask.
If the field is not a bitfield, then bitmask should be set to 0.

blurb
-----
This is a string giving a proper description of the field.
It should be at least one grammatically complete sentence.
It is meant to provide a more detailed description of the field than the
name alone provides. This information will be used in the man page, and
in a future GUI display-filter creation tool. We might also add tooltips
to the labels in the GUI protocol tree, in which case the blurb would
be used as the tooltip text.


1.6.1 Field Registration.

Protocol registration is handled by creating an instance of the
header_field_info struct (or an array of such structs), and
calling the registration function along with the registration ID of
the protocol that is the parent of the fields. Here is a complete example:

	static int proto_eg = -1;
	static int hf_field_a = -1;
	static int hf_field_b = -1;

	static hf_register_info hf[] = {

		{ &hf_field_a,
		{ "Field A",	"proto.field_a", FT_UINT8, BASE_HEX, NULL,
			0xf0, "Field A represents Apples" }},

		{ &hf_field_b,
		{ "Field B",	"proto.field_b", FT_UINT16, BASE_DEC, VALS(vs),
			0x0, "Field B represents Bananas" }}
	};

	proto_eg = proto_register_protocol("Example Protocol",
	    "PROTO", "proto");
	proto_register_field_array(proto_eg, hf, array_length(hf));

Be sure that your array of hf_register_info structs is declared 'static',
since the proto_register_field_array() function does not create a copy
of the information in the array... it uses that static copy of the
information that the compiler created inside your array. Here's the
layout of the hf_register_info struct:

typedef struct hf_register_info {
	int			*p_id;	/* pointer to parent variable */
	header_field_info	hfinfo;
} hf_register_info;

Also be sure to use the handy array_length() macro found in packet.h
to have the compiler compute the array length for you at compile time.

1.6.2 Adding Items and Values to the Protocol Tree.

A protocol item is added to an existing protocol tree with one of a
handful of proto_tree_add_XXX() functions.

Subtrees can be made with the proto_item_add_subtree() function:

	item = proto_tree_add_item(....);
	new_tree = proto_item_add_subtree(item, tree_type);

This will add a subtree under the item in question; a subtree can be
created under an item made by any of the "proto_tree_add_XXX" functions,
so that the tree can be given an arbitrary depth.

Subtree types are integers, assigned by
"proto_register_subtree_array()".  To register subtree types, pass an
array of pointers to "gint" variables to hold the subtree type values to
"proto_register_subtree_array()":

	static gint ett_eg = -1;
	static gint ett_field_a = -1;

	static gint *ett[] = {
		&ett_eg,
		&ett_field_a,
	};

	proto_register_subtree_array(ett, array_length(ett));

in your "register" routine, just as you register the protocol and the
fields for that protocol.

There are several functions that the programmer can use to add either
protocol or field labels to the proto_tree:

	proto_item*
	proto_tree_add_item(tree, id, start, length, value);

	proto_item*
	proto_tree_add_item_hidden(tree, id, start, length, value);

	proto_item*
	proto_tree_add_protocol_format(tree, id, start, length, format, ...);

	proto_item *
	proto_tree_add_bytes_format(tree, id, start, length, start_ptr,
	    format, ...);

	proto_item *
	proto_tree_add_time_format(tree, id, start, length, value_ptr,
	    format, ...);

	proto_item *
	proto_tree_add_ipxnet_format(tree, id, start, length, value,
	    format, ...);

	proto_item *
	proto_tree_add_ipv4_format(tree, id, start, length, value,
	    format, ...);

	proto_item *
	proto_tree_add_ipv6_format(tree, id, start, length, value_ptr,
	    format, ...);

	proto_item *
	proto_tree_add_ether_format(tree, id, start, length, value_ptr,
	    format, ...);

	proto_item *
	proto_tree_add_string_format(tree, id, start, length, value_ptr,
	    format, ...);

	proto_item *
	proto_tree_add_boolean_format(tree, id, start, length, value,
	    format, ...);

	proto_item *
	proto_tree_add_uint_format(tree, id, start, length, value,
	    format, ...);

	proto_item*
	proto_tree_add_text(tree, start, length, format, ...);

	proto_item*
	proto_tree_add_notext(tree, start, length);

The 'tree' argument is the tree to which the item is to be added.  The
'start' argument is the offset from the beginning of the frame (not the
offset from the beginning of the part of the packet belonging to this
protocol, but the offset from the beginning of the frame as a whole) of
the item being added, and the 'length' argument is the length, in bytes,
of the item.

The length of some items cannot be determined until the item has been
dissected; to add such an item, add it with a length of 0, and, when the
dissection is complete (or fails because the packet is too short), set
the length with 'proto_item_set_len()':

	void
	proto_item_set_len(ti, length);

The "ti" argument is the value returned by the call that added the item
to the tree, and the "length" argument is the length of the item.

proto_tree_add_item()
---------------------
proto_tree_add_item is used when you wish to do no special formatting. 
The item added to the GUI tree will contain the name (as passed in the
proto_register_*() function) and any value.  If your field does have a
value, it is passed after the length variable (notice the ellipsis in
the function prototype).

Now that the proto_tree has detailed information about bitfield fields,
you can use proto_tree_add_item() with no extra processing to add bitfield
values to your tree.  Here's an example. Take the Format Identifer (FID)
field in the Transmission Header (TH)  portion of the SNA protocol. The
FID is the high nibble of the first byte of the TH. The FID would be
registered like this:

	name		= "Format Identifer"
	abbrev		= "sna.th.fid"
	type		= FT_UINT8
	display		= BASE_HEX
	strings		= sna_th_fid_vals
	bitmask		= 0xf0

The bitmask contains the value which would leave only the FID if bitwise-ANDed
against the parent field, the first byte of the TH.

The code to add the FID to the tree would be;

	guint8 th_0 = pd[offset];
	proto_tree_add_item(bf_tree, hf_sna_th_fid, offset, 1, th_0);

Note: we do not do *any* manipulation of th_0 in order to get the FID value.
We just pass it to proto_tree_add_item(). The proto_tree already has
the information about bitmasking and bitshifting, so it does the work
of masking and shifting for us! This also means that you no longer
have to crate value_string structs with the values bitshifted. The
value_string for FID looks like this, even though the FID value is
actually contained in the high nibble. (You'd expect the values to be
0x0, 0x10, 0x20, etc.)

/* Format Identifier */
static const value_string sna_th_fid_vals[] = {
	{ 0x0,	"SNA device <--> Non-SNA Device" },
	{ 0x1,	"Subarea Node <--> Subarea Node" },
	{ 0x2,	"Subarea Node <--> PU2" },
	{ 0x3,	"Subarea Node or SNA host <--> Subarea Node" },
	{ 0x4,	"?" },
	{ 0x5,	"?" },
	{ 0xf,	"Adjaced Subarea Nodes" },
	{ 0,	NULL }
};

The final implication of this is that display filters work the way you'd
naturally expect them to. You'd type "sna.th.fid == 0xf" to find Adjacent
Subarea Nodes. The user does not have to shift the value of the FID to
the high nibble of the byte ("sna.th.fid == 0xf0") as was necessary
before Ethereal 0.7.6.

proto_tree_add_item_hidden()
----------------------------
proto_tree_add_item_hidden is used to add fields and values to a tree,
but not show them on a GUI tree.  The caller may want a value to be
included in a tree so that the packet can be filtered on this field, but
the representation of that field in the tree is not appropriate.  An
example is the token-ring routing information field (RIF).  The best way
to show the RIF in a GUI is by a sequence of ring and bridge numbers. 
Rings are 3-digit hex numbers, and bridges are single hex digits:

	RIF: 001-A-013-9-C0F-B-555

In the case of RIF, the programmer should use a field with no value and
use proto_tree_add_item_format() to build the above representation. The
programmer can then add the ring and bridge values, one-by-one, with
proto_tree_add_item_hidden() so that the user can then filter on or
search for a particular ring or bridge. Here's a skeleton of how the
programmer might code this.

	char *rif;
	rif = create_rif_string(...);

	proto_tree_add_item_format(tree, hf_tr_rif_label,..., "RIF: %s", rif);

	for(i = 0; i < num_rings; i++) {
		proto_tree_add_item_hidden(tree, hf_tr_rif_ring, ..., ring[i]);
	}
	for(i = 0; i < num_rings - 1; i++) {
		proto_tree_add_item_hidden(tree, hf_tr_rif_ring, ..., bridge[i]);
	}

The logical tree has these items:

	hf_tr_rif_label, text="RIF: 001-A-013-9-C0F-B-555", value = NONE
	hf_tr_rif_ring,  hidden, value=0x001
	hf_tr_rif_bridge, hidden, value=0xA
	hf_tr_rif_ring,  hidden, value=0x013
	hf_tr_rif_bridge, hidden, value=0x9
	hf_tr_rif_ring,  hidden, value=0xC0F
	hf_tr_rif_bridge, hidden, value=0xB
	hf_tr_rif_ring,  hidden, value=0x555

GUI or print code will not display the hidden fields, but a display
filter or "packet grep" routine will still see the values. The possible
filter is then possible:

	tr.rif_ring eq 0x013

proto_tree_add_protocol_format()
----------------------------
proto_tree_add_protocol_format is used to add the top-level item for the
protocol when the dissector routines wants complete control over how the
field and value will be represented on the GUI tree.  The ID value for
the protocol is passed in as the "id" argument; the rest of the
arguments are a "printf"-style format and any arguments for that format. 
The caller must include the name of the protocol in the format; it is
not added automatically as in proto_tree_add_item().

proto_tree_add_bytes_format()
proto_tree_add_time_format()
proto_tree_add_ipxnet_format()
proto_tree_add_ipv4_format()
proto_tree_add_ipv6_format()
proto_tree_add_ether_format()
proto_tree_add_string_format()
proto_tree_add_boolean_format()
proto_tree_add_uint_format()
----------------------------

The other "proto_tree_add_XXX_format" routines are used to add items to
the protocol tree when the dissector routines wants complete control
over how the field and value will be represented on the GUI tree.

For "proto_tree_add_time_format", the "value_ptr" argument is a pointer
to a "struct timeval" containing the time to be added; for those other
functions that take a "value_ptr" argument, that argument is a pointer
to the first byte of the value to be added.

For the other functions, the "value" argument is a 32-bit integral value
to be added.

The rest of the arguments are a "printf"-style format and any arguments
for that format.  The caller must include the name of the field in the
format; it is not added automatically as in proto_tree_add_item().

proto_tree_add_text()
---------------------
The fourth function, proto_tree_add_text(), is used to add a label to
the GUI tree.  It will contain no value, so it is not searchable in the
display filter process.  This function was needed in the transition from
the old-style proto_tree to this new-style proto_tree so that Ethereal
would still decode all protocols w/o being able to filter on all
protocols and fields.  Otherwise we would have had to cripple Ethereal's
functionality while we converted all the old-style proto_tree calls to
the new-style proto_tree calls.

This can also be used for items with subtrees, which may not have values
themselves - the items in the subtree are the ones with values.

proto_tree_add_notext()
-----------------------
The fifth function, proto_tree_add_notext(), is used to add an item to
the logical tree that will have only a label, and no value (so it is not
searchable in the display filter process), but that doesn't yet have a
label, either.  This is for items where the value is to be filled in
later.  This is typically used for an item with a subtree, where the
label is to contain a summary of the subtree, with the values of some of
the fields in the subtree shown in the label of the item for the subtree
as a whole; the item can be created as a placeholder, with the label
added when the dissection is complete - and, if the dissection doesn't
complete because the packet is too short and not all the required fields
are present, the label could be set to something indicating this.

The text is set by 'proto_item_set_text()':

	void
	proto_tree_set_text(proto_item *ti, ...);

which takes as an argument the value returned by
'proto_tree_add_notext()', a 'printf'-style format string, and a set of
arguments corresponding to '%' format items in that string.  For
example, early in the dissection, one might do:

	ti = proto_tree_add_notext(tree, offset, length);

and later do

	proto_item_set_text(ti, "%s: %s", type, value);

after the "type" and "value" fields have been extracted and dissected.

1.7 Utility routines

1.7.1 match_strval and val_to_str

A dissector may need to convert a value to a string, using a
'value_string' structure, by hand, rather than by declaring a field with
an associated 'value_string' structure; this might be used, for example,
to generate a COL_INFO line for a frame.

'match_strval()' will do that:

	gchar*
	match_strval(guint32 val, const value_string *vs)

It will look up the value 'val' in the 'value_string' table pointed to
by 'vs', and return either the corresponding string, or NULL if the
value could not be found in the table.

'val_to_str()' can be used to generate a string for values not found in
the table:

	gchar*
	val_to_str(guint32 val, const value_string *vs, const char *fmt)

If the value 'val' is found in the 'value_string' table pointed to by
'vs', 'val_to_str' will return the corresponding string; otherwise, it
will use 'fmt' as an 'sprintf'-style format, with 'val' as an argument,
to generate a string, and will return a pointer to that string. 
(Currently, it has three 64-byte static buffers, and cycles through
them; this permits the results of up to three calls to 'val_to_str' to
be passed as arguments to a routine using those strings.)


1.8 Calling Other Dissector 


1.8.1 TVBuffer Calling Old Style Dissector 

When a TVBuffer based dissector is calling a old style dissector it must
create the data structures need to make the call.  The tvb_compat function
is used to set the pd value and the offset value.


void
dissect_my(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{

	tvbuff_t	*next_tvb;
	const guint8	*next_pd;
	int		next_offset;

/* create new tv_buffer that starts at the current offset */
	next_tvb = tvb_new_subset(tvb, offset, -1, -1);

/* set the pd and offset values need to call next dissector */
	tvb_compat(next_tvb, &next_pd, &next_offset);

/* call next dissector */
	dissect_next( next_pd, next_offset, pinfo->fd, tree, 
			END_OF_FRAME - next_offset);


1.8.2 TVBuffer Calling TVBuffer Dissector 

NOTE: This is discussed in the README.tvbuff file.  For more 
information on tvbuffers consult that file.

As each dissector completes its portion of the protocol analysis, it
is expected to create a new tvbuff of type TVBUFF_SUBSET which
contains the payload portion of the protocol (that is, the bytes
that are relevant to the next dissector).

The syntax for creating a new TVBUFF_SUBSET is:

next_tvb = tvb_new_subset(tvb, offset, length, reported_length)

Where:
	tvb is the tvbuff that the dissector has been working on. It
	can be a tvbuff of any type.

	next_tvb is the new TVBUFF_SUBSET.

	offset is the byte offset of 'tvb' at which the new tvbuff
	should start.  The first byte is the 0th byte.

	length is the number of bytes in the new TVBUFF_SUBSET. A length
	argument of -1 says to use as many bytes as are available in
	'tvb'.

	reported_length is the number of bytes that the current protocol
	says should be in the payload. A reported_length of -1 says that
	the protocol doesn't say anything about the size of its payload.


An example from packet-ipx.c -

void
dissect_ipx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
        tvbuff_t        *next_tvb;
        int             reported_length, available_length;

 
        /* Make the next tvbuff */

/* IPX does have a length value in the header, so calculate report_length */
   Set this to -1 if there isn't any length information in the protocol
*/
        reported_length = ipx_length - IPX_HEADER_LEN;

/* Calculate the available data in the packet, 
   set this to -1 to use all the data in the tv_buffer
*/
        available_length = tvb_length(tvb) - IPX_HEADER_LEN;

/* Create the tvbuffer for the next dissector */
        next_tvb = tvb_new_subset(tvb, IPX_HEADER_LEN,
                        MIN(available_length, reported_length),
                        reported_length);

/* call the next dissector */
	dissector_next( next_tvb, pinfo, tree);



1.8.3 Old Style Dissector calling TVBuffer Dissector

When an old style dissector calls a tvbuffer type dissector it must
create the tvbuffer to pass to the tvbuffer dissector.  This is done
with the tvb_create_from_top call.  The functions requires one
parameter, the offset to the start of the data for the next dissector.

An example -

static void
dissect_my(const u_char *pd, int offset, frame_data *fd, proto_tree *tree) {

	tvbuff_t *tvb;
	int offset = 0;

/* create the tvbuffer for the next dissector */
	tvb = tvb_create_from_top(offset);

	dissector_next(tvb, &pi, tree);


1.9 Editing Makefile.am and Makefile.nmake to add your dissector.

To arrange that your dissector will be built as part of Ethereal, you
must add the name of the source file for your dissector, and the header
file that declares your main dissector routine, to the
'DISSECTOR_SOURCES' macro in the 'Makefile.am' file in the top-level
directory, and must add the name the object file for the dissector will
have when built on Windows - if your dissector source file is
'packet-PROTOABBREV.c', the object file for it will be
'packet-PROTOABBREV.obj' - to the 'DISSECTOR_OBJECTS' macro in the
'Makefile.nmake' file in the top-level directory.  (Note that this is
for modern versions of UNIX, so there is no 14-character limitation on
file names, and for modern versions of Windows, so there is no
8.3-character limitation on file names.)

Please remember to update both files; it may not be necessary to do so
in order for you to build Ethereal on your machine, but both changes
will need to be checked in to the Ethereal source code, to allow it to
build on all platforms.

1.10 Using the CVS source code tree.

1.11 Submitting code for your new dissector.

2. Advanced dissector topics.

2.1 ?? 

2.2 Following "conversations."

In ethereal a conversation is defined as a series of data packet between two
address:port combinations.  A conversation is not sensitive to the direction of
the packet.  The same conversation will be returned for a packet bound from
ServerA:1000 to ClientA:2000 and the packet from ClientA:2000 to ServerA:1000.

There are two routine that you will use to work with a conversation:
conversation_new and find_conversation.


2.2.1 The conversation_init function.

This is an internal routine for the conversation code.  As such the you will not
have to call this routine.  Just be aware that this routine is called at the
start of each capture and before the packets are filtered with a display filter.
The routine will destroy all stored conversations.  This routine does NOT clean
up any data pointers that is passed in the conversation_new 'data' variable.
You are responsible for this clean up if you pass a malloc'ed pointer in this
variable.

See item 2.2.4 for more information about the 'data' pointer.


2.2.2 The conversation_new function.

This routine will create a new conversation based upon the source address:port
and destination address:port. If you want store a pointer to memory structure it
should be passed in the conversation_new 'data' variable. The ptype variable is
used to differentiate between conversations over different protocols, ie. TCP
and UDP. The options variable is used to define a conversation that will accept 
any destination address and/or port.  Set options = 0 if the destination port and
address are know when conversation_new is called.  See section 2.4 for more
information on usage of the options parameter.

The conversation_new prototype:
	conversation_t *conversation_new(address *src, address *dst, port_type ptype,
	    guint32 src_port, guint32 dst_port, void *data, guint options);

Where:
	address* src 	= data packet source address
	address* src 	= data packet destination address
	port_type ptype 	= port type, this is defined in packet.h
	guint32 src_port	= data packet source port
	guint32 dst_port	= data packet destination port
 	void *data		= dissector data structure
	guint options	= conversation options, NO_DST_ADDR and/or NO_DST_PORT



2.2.3 The find_conversation function.

Call this routine to lookup a conversation. If no conversation is found the
routine will return a NULL value.  You don't have to worry about interchanging
the source and destination values.  The conversation routine will automatically
return the same conversation for packets traveling in both directions. The
options value is used to define is the destination address and/or port should
be use to match the lookup.  The matching conversation must have the same options
as the value of the find call.


2.2.4 The example conversation code with GMemChunk's

For a conversation between two IP addresses and ports you can use this as an
example.  This example uses the GMemChunk to allocate memory and stores the data
pointer in the conversation 'data' variable.

NOTE: Remember to register the init routine (my_dissector_init) in the
protocol_register routine.


/************************ Globals values ************************/

/* the number of entries in the memory chunk array */
#define my_init_count 10

/* define your structure here */
typedef struct {

}my_entry_t;

/* the GMemChunk base structure */
static GMemChunk *my_vals = NULL;


/********************* in the dissector routine *********************/

/* the local variables in the dissector */

conversation_t *conversation;
my_entry_t *data_ptr


/* look up the conversation */
/* pi is a global variable of type packet_info, see  packet.h */

conversation = find_conversation( &pi.src, &pi.dst, pi.ptype,
	pi.srcport, pi.destport, 0);

/* if conversation found get the data pointer that you stored */
if ( conversation)
    data_ptr = (my_entry_t*)conversation->data;
else {

    /* new conversation create local data structure */

    data_ptr = g_mem_chunk_alloc(my_protocol_vals);

    /*** add your code here to setup the new data structure ***/

    /* create the conversation with your data pointer  */

    conversation_new( &pi.src, &pi.dst, pi.ptype,
	    pi.srcport, pi.destport, (void*)data_ptr, 0);
}

/* at this point the conversation data is ready */


/******************* in the dissector init routine *******************/

#define proto_hash_init_count 20

static void
my_dissector_init( void){

    /* destroy memory chunks if needed */

    if ( my_vals)
	g_mem_chunk_destroy(my_vals);

    /* now create memory chunks */

    my_vals = g_mem_chunk_new( "my_proto_vals",
	    sizeof( _entry_t),
	    my_init_count * sizeof( my_entry_t),
	    G_ALLOC_AND_FREE);
}

/***************** in the protocol register routine *****************/

/* register re-init routine */

register_init_routine( &my_dissector_init);


2.2.4 The example conversation code using conversation index field

Sometimes the conversation isn't enough to define a unique data storage value
for the network traffic.  For example if you are storing information about requests
carried in a conversation, the request may have an identifier that is used to 
define the request. In this case the conversation and the identifier are required
to find the data storage pointer.  You can use the conversation data structure
index value to uniquely define the conversation.  

See packet-afs.c for an example of how to use the conversation index.  In
this dissector multiple requests are sent in the same conversation.  To store
information for each request the dissector has an internal hash table based
upon the conversation index and values inside the request packets. 


/* in the dissector routine */

/* to find a request value, first lookup conversation to get index */
/* then used the conversation index, and request data to find data */
/* in the local hash table */

	conversation = find_conversation(&pi.src, &pi.dst, pi.ptype,
	    pi.srcport, pi.destport, 0);
	if (conversation == NULL) {
		/* It's not part of any conversation - create a new one. */
		conversation = conversation_new(&pi.src, &pi.dst, pi.ptype,
		    pi.srcport, pi.destport, NULL, 0);
	}

	request_key.conversation = conversation->index;	
	request_key.service = pntohs(&rxh->serviceId);
	request_key.callnumber = pntohl(&rxh->callNumber);

	request_val = (struct afs_request_val *) g_hash_table_lookup(
		afs_request_hash, &request_key);

	/* only allocate a new hash element when it's a request */
	opcode = 0;
	if ( !request_val && !reply)
	{
		new_request_key = g_mem_chunk_alloc(afs_request_keys);
		*new_request_key = request_key;

		request_val = g_mem_chunk_alloc(afs_request_vals);
		request_val -> opcode = pntohl(&afsh->opcode);
		opcode = request_val->opcode;

		g_hash_table_insert(afs_request_hash, new_request_key,
			request_val);
	}



2.3 Dynamic conversation dissector registration


NOTE: This sections assumes that all information is available to
	create a complete conversation, source port/address and
	destination port/address.  If either the destination port or
	address is know, see section 2.4 Dynamic server port dissector
	registration.

For protocols that negotiate a secondary port connection, for example
packet-msproxy.c, a conversation can install a dissector to handle 
the secondary protocol dissection.  After the conversation is created
for the negotiated ports use the conversation_set_dissector to define
the dissection routine.

An example -


/* prototype for the dynamic dissector */
static void sub_dissector( tvbuff_t *tvb, packet_info *pinfo,
                proto_tree *tree);


/* in the main protocol dissector, where the next dissector is setup */

/* if conversation has a data field, create it and load structure */

        new_conv_info = g_mem_chunk_alloc( new_conv_vals);
        new_conv_info->data1 = value1;

/* create the conversation for the dynamic port */
        conversation = conversation_new( &pi.src, &pi.dst, protocol,
                src_port, dst_port, new_conv_info, 0);

/* set the dissector for the new conversation */
        conversation_set_dissector(conversation, sub_dissector);



2.4 Dynamic server port dissector registration

NOTE:  While this example used both NO_DST_ADDR and NO_DST_PORT to 
create a conversation with only the source port and address set, this
isn't a requirement.  Either the destination port or address can be 
set when the conversation is create. 

For protocols that define a server address and port for a secondary
protocol, a conversation can be use to link a protocol dissector to
the server port and address.  The key is to create the new 
conversation with the destination address and port set to the accept
any values.  

There are two support routines that will allow the destination port and/or
address to be set latter.  

conversation_set_port( conversation_t *conv, guint32 port);
conversation_set_addr( conversation_t *conv, address addr);

These routines will change the destination information for the conversation.
So, the server port conversation will be converted into a more complete
conversation definition. Don't use these routines if you want create a 
conversation between the server and client and retain the server port
definition, you must create a new conversation.


An example -

/* prototype for the dynamic dissector */
static void sub_dissector( tvbuff_t *tvb, packet_info *pinfo,
                proto_tree *tree);


/* in the main protocol dissector, where the next dissector is setup */

/* if conversation has a data field, create it and load structure */

        new_conv_info = g_mem_chunk_alloc( new_conv_vals);
        new_conv_info->data1 = value1;

/* create the conversation for the dynamic server address and port 	*/
/* NOTE: The destination values don't matter because the NO_DST_ADDR 	*/
/*	   NO_DST_PORT options are set. 						*/

        conversation = conversation_new( &server_src_addr, 0, protocol,
                server_src_port, 0, new_conv_info, NO_DST_ADDR | NO_DST_PORT);

/* set the dissector for the new conversation */
        conversation_set_dissector(conversation, sub_dissector);


2.5 Per packet information

Information can be stored for each data packet that is process by the dissector.
The information is added with the p_add_proto_data function and retreived with the 
p_get_proto_data function.  The data pointers passed into the p_add_proto_data are
not managed by the proto_data routines. If you use malloc or any other dynamic 
memory allocation scheme, you must release the data when it isn't required.

void
p_add_proto_data(frame_data *fd, int proto, void *proto_data)
void *
p_get_proto_data(frame_data *fd, int proto)

Where: 
	fd         - The fd pointer in the pinfo structure, usually pinfo->fd
	proto      - Protocol id returned by the proto_register_protocol call during initialization
	proto_data - pointer to the dissector data.


2.5 User Preferences

If the dissector has user options, there is support for adding these preferences
to a configuration dialog.

You must register the module with the preferences routine with -

module_t *prefs_register_protocol(proto_id, void (*apply_cb)(void))

Where: proto_id   - the value returned by "proto_register_protocol()" when
		    the protocol was registered
	 apply_cb - Callback routine that is call when preferences are applied


Then you can register the fields that can be configured by the user with these routines -

	/* Register a preference with an unsigned integral value. */
	void prefs_register_uint_preference(module_t *module, const char *name,
	    const char *title, const char *description, guint base, guint *var);

	/* Register a preference with an Boolean value. */
	void prefs_register_bool_preference(module_t *module, const char *name,
	    const char *title, const char *description, gboolean *var);

	/* Register a preference with an enumerated value. */
	void prefs_register_enum_preference(module_t *module, const char *name,
	    const char *title, const char *description, gint *var,
	    const enum_val *enumvals, gboolean radio_buttons)

	/* Register a preference with a character-string value. */
	void prefs_register_string_preference(module_t *module, const char *name,
	    const char *title, const char *description, char **var)

Where: module - Returned by the prefs_register_protocol routine
	 name   - Appended to the module name to identify the field in the preference file
	 title  - Field title in the preferences dialog
	 description - Comments added to the preference file above the 
			preference value
	 var	  - pointer to the storage location that is updated when the
		    field is changed in the preference dialog box
	 enumvals - an array of enum_val structures.  This must be NULL terminated
	 radio_buttons - Is the enumvals a list of radio buttons?


An example from packet-bxxp.c -
	
  proto_bxxp = proto_register_protocol("Blocks eXtensible eXchange Protocol",
				       "BXXP", "bxxp");

  /* Register our configuration options for BXXP, particularly our port */

  bxxp_module = prefs_register_protocol(proto_bxxp, proto_reg_handoff_bxxp);

  prefs_register_uint_preference(bxxp_module, "tcp.port", "BXXP TCP Port",
				 "Set the port for BXXP messages (if other"
				 " than the default of 10288)",
				 10, &global_bxxp_tcp_port);

  prefs_register_bool_preference(bxxp_module, "strict_header_terminator", 
				 "BXXP Header Requires CRLF", 
				 "Specifies that BXXP requires CRLF as a "
				 "terminator, and not just CR or LF",
				 &global_bxxp_strict_term);


3. Plugins

Writing a "plugin" dissector is not very different from writing a standard one.
All the functions described in the first part of this file can be used in
plugins exactly as they are used in standard dissectors.

However, there are a few things you need to do (you can look at the gryphon
plugin for an example) :

3.1 Needed headers

#include "plugins/plugin_api.h"

Some OSes (Win32) have DLLs that cannot reference symbols in the parent
executable. So, the executable needs to provide a table of pointers for the DLL
plugin to use. The plugin_api.h header provides definitions for this (or empty
definitions on OSes which don't need this).

#include "moduleinfo.h"

This header is optional. It is used by the gryphon plugin to provide a VERSION
macro (different from the ethereal VERSION).

Ex :
$ cat moduleinfo.h
/* Included *after* config.h, in order to re-define these macros */
#ifdef VERSION
#undef VERSION
#endif

/* Plugin version number */
#define VERSION "0.1.2"

#include <gmodule.h>

This header is required to define G_MODULE_EXPORT, which must be used
when defining constants and functions exported by the plugin.

"gmodule.h" includes "glib.h", so you don't need to include "glib.h" if
you include "gmodule.h"; however, "glib.h" is protected from multiple
inclusion by #ifdefs, so it's safe to include it after including
"gmodule.h".

3.2 Exported constants

Plugins need to provide the following exported constants:

G_MODULE_EXPORT const gchar version[] = VERSION;

version       : a version number associated with the plugin.

3.3 Exported functions

The following two functions need to be exported by the plugin:

G_MODULE_EXPORT void plugin_init(plugin_address_table_t *pat)

This function is called by Ethereal when the plugin is initialized; it's
similar to the "proto_register_XXX()" routine for a non-plugin
dissector, except for the name and the call to
"plugin_address_table_init()".

Here is a sample code for the function:

	/* initialise the table of pointers needed in Win32 DLLs */
	plugin_address_table_init(pat);

	/* register the new protocol, protocol fields, and subtrees */
	if (proto_xxx == -1) { /* execute protocol initialization only once */
	  proto_xxx = proto_register_protocol("XXX Protocol", "XXX", "xxx");
	  proto_register_field_array(proto_xxx, hf, array_length(hf));
	  proto_register_subtree_array(ett, array_length(ett));
	}

G_MODULE_EXPORT void plugin_reg_handoff(void)

This function is called by Ethereal after all dissectors, including all
plugins, are initialized; it's similar to the "proto_reg_handoff_XXX()"
routine for a non-plugin dissector, except for the name. 

4.0 Extending Wiretap.

5.0 Adding new capabilities.




James Coe <jammer@cin.net>
Gilbert Ramirez <gram@xiexie.org>
Jeff Foster <jfoste@woodward.com>
Olivier Abad <oabad@cybercable.fr>
Laurent Deniel <deniel@worldnet.fr>
