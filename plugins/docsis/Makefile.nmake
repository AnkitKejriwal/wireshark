# Makefile.nmake
# nmake file for for Ethereal/docsis subdissectors
#
# $Id$
#

include ..\..\config.nmake

############### no need to modify below this line #########

include Makefile.common

CFLAGS=/DHAVE_CONFIG_H /I../.. /I../../wiretap $(GLIB_CFLAGS) \
	/I$(PCAP_DIR)\include -D_U_="" $(LOCAL_CFLAGS)

LDFLAGS = /NOLOGO /INCREMENTAL:no /MACHINE:I386 $(LOCAL_LDFLAGS)

!IFDEF ENABLE_LIBETHEREAL
LINK_PLUGIN_WITH=..\..\epan\libethereal.lib
CFLAGS=/DHAVE_WIN32_LIBETHEREAL_LIB /D_NEED_VAR_IMPORT_ $(CFLAGS)

DISSECTOR_OBJECTS = $(DISSECTOR_SRC:.c=.obj)

OBJECTS=$(DISSECTOR_OBJECTS) plugin.obj register.obj

docsis.dll docsis.exp docsis.lib : $(OBJECTS) $(LINK_PLUGIN_WITH) 
	link -dll /out:docsis.dll $(LDFLAGS) $(OBJECTS) $(LINK_PLUGIN_WITH)  \
	$(GLIB_LIBS)

#
# Build "register.c", which contains a function "register_all_protocols()"
# that calls the register routines for all protocols.
#
# We do this by grepping through sources.  If that turns out to be too slow,
# maybe we could just require every .o file to have an register routine
# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
#
# Formatting conventions:  The name of the proto_register_* routines must
# start in column zero, or must be preceded only by "void " starting in
# column zero, and must not be inside #if.
#
# We assume that all dissector routines are in "packet-XXX.c" files.
#
# For some unknown reason, having a big "for" loop in the Makefile
# to scan all the "packet-XXX.c" files doesn't work with some "make"s;
# they seem to pass only the first few names in the list to the shell,
# for some reason.
#
# Therefore, we have a script to generate the "register.c" file.
#
# The first argument is the name of the file to write.
# The second argument is the directory in which the source files live.
# All subsequent arguments are the files to scan.
#
# On Windows, however, that script runs slowly, as multiple greps
# and seds are run for each input file, so, if Python is present
# (as indicated by PYTHON being defined), we run a faster Python
# script to do that work instead.  That script doesn't take the name
# of the file to write as an argument; it always writes to
# "register.c".
#
register.c: $(DISSECTOR_SRC)
!IFDEF PYTHON
	@echo Making register.c (using python)
	@$(PYTHON) ../../tools/make-reg-dotc.py . $(DISSECTOR_SRC)
!ELSE
	@echo Making register.c (using sh)
	@$(SH) ../../tools/make-reg-dotc register.c . $(DISSECTOR_SRC)
!ENDIF

!ENDIF

clean:
	rm -f $(OBJECTS) docsis.dll docsis.exp docsis.lib *.pdb

distclean: clean

maintainer-clean: distclean
