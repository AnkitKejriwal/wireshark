Index: aclocal.m4
===================================================================
RCS file: /tcpdump/master/libpcap/aclocal.m4,v
retrieving revision 1.66
diff -c -r1.66 aclocal.m4
*** aclocal.m4	1999/10/30 04:41:48	1.66
--- aclocal.m4	2000/08/13 07:23:45
***************
*** 415,420 ****
--- 415,454 ----
      fi])
  
  dnl
+ dnl Checks to see if the dl_hp_ppa_info_t struct has the HP-UX 11.00
+ dnl dl_module_id_1 member
+ dnl
+ dnl usage:
+ dnl
+ dnl	AC_LBL_HP_PPA_INFO_T_DL_MODULE_ID_1
+ dnl
+ dnl results:
+ dnl
+ dnl	HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1 (defined)
+ dnl
+ dnl NOTE: any compile failure means we conclude that it doesn't have
+ dnl that member, so if we don't have DLPI, don't have a <sys/dlpi_ext.h>
+ dnl header, or have one that doesn't declare a dl_hp_ppa_info_t type,
+ dnl we conclude it doesn't have that member (which is OK, as either we
+ dnl won't be using code that would use that member, or we wouldn't
+ dnl compile in any case).
+ dnl
+ AC_DEFUN(AC_LBL_HP_PPA_INFO_T_DL_MODULE_ID_1,
+     [AC_MSG_CHECKING(if dl_hp_ppa_info_t struct has dl_module_id_1 member)
+     AC_CACHE_VAL(ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1,
+ 	AC_TRY_COMPILE([
+ #	include <sys/types.h>
+ #	include <sys/dlpi.h>
+ #	include <sys/dlpi_ext.h>],
+ 	[u_int i = sizeof(((dl_hp_ppa_info_t *)0)->dl_module_id_1)],
+ 	ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1=yes,
+ 	ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1=no))
+     AC_MSG_RESULT($ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1)
+     if test $ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1 = yes ; then
+ 	    AC_DEFINE(HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1)
+     fi])
+ 
+ dnl
  dnl Checks to see if -R is used
  dnl
  dnl usage:
Index: configure
===================================================================
RCS file: /tcpdump/master/libpcap/configure,v
retrieving revision 1.5
diff -c -r1.5 configure
*** configure	1999/11/01 15:56:40	1.5
--- configure	2000/08/13 07:23:50
***************
*** 1822,1829 ****
  
      fi
  
  echo $ac_n "checking if unaligned accesses fail""... $ac_c" 1>&6
! echo "configure:1827: checking if unaligned accesses fail" >&5
      if eval "test \"`echo '$''{'ac_cv_lbl_unaligned_fail'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 1822,1865 ----
  
      fi
  
+ echo $ac_n "checking if dl_hp_ppa_info_t struct has dl_module_id_1 member""... $ac_c" 1>&6
+ echo "configure:1827: checking if dl_hp_ppa_info_t struct has dl_module_id_1 member" >&5
+     if eval "test \"`echo '$''{'ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 1832 "configure"
+ #include "confdefs.h"
+ 
+ #	include <sys/types.h>
+ #	include <sys/dlpi.h>
+ #	include <sys/dlpi_ext.h>
+ int main() {
+ u_int i = sizeof(((dl_hp_ppa_info_t *)0)->dl_module_id_1)
+ ; return 0; }
+ EOF
+ if { (eval echo configure:1842: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+   rm -rf conftest*
+   ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1=no
+ fi
+ rm -f conftest*
+ fi
+ 
+     echo "$ac_t""$ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1" 1>&6
+     if test $ac_cv_lbl_dl_hp_ppa_info_t_has_dl_module_id_1 = yes ; then
+ 	    cat >> confdefs.h <<\EOF
+ #define HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1 1
+ EOF
+ 
+     fi
+ 
  echo $ac_n "checking if unaligned accesses fail""... $ac_c" 1>&6
! echo "configure:1863: checking if unaligned accesses fail" >&5
      if eval "test \"`echo '$''{'ac_cv_lbl_unaligned_fail'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 1912,1918 ****
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:1916: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1948,1954 ----
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:1952: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
Index: configure.in
===================================================================
RCS file: /tcpdump/master/libpcap/configure.in,v
retrieving revision 1.71
diff -c -r1.71 configure.in
*** configure.in	1999/11/01 15:56:40	1.71
--- configure.in	2000/08/13 07:23:51
***************
*** 175,180 ****
--- 175,182 ----
  
  AC_LBL_SOCKADDR_SA_LEN
  
+ AC_LBL_HP_PPA_INFO_T_DL_MODULE_ID_1
+ 
  AC_LBL_UNALIGNED_ACCESS
  
  if test -r ${srcdir}/lbl/gnuc.h ; then
Index: pcap-dlpi.c
===================================================================
RCS file: /tcpdump/master/libpcap/pcap-dlpi.c,v
retrieving revision 1.52.1.1
diff -c -r1.52.1.1 pcap-dlpi.c
*** pcap-dlpi.c	1999/10/07 23:46:40	1.52.1.1
--- pcap-dlpi.c	2000/08/13 07:23:52
***************
*** 246,255 ****
  	}
  	memset(p, 0, sizeof(*p));
  
  	/*
! 	** Determine device and ppa
  	*/
! 	cp = strpbrk(device, "0123456789");
  	if (cp == NULL) {
  		sprintf(ebuf, "%s missing unit number", device);
  		goto bad;
--- 246,266 ----
  	}
  	memset(p, 0, sizeof(*p));
  
+ #ifdef HAVE_DEV_DLPI
  	/*
! 	** Remove any "/dev/" on the front of the device.
  	*/
! 	cp = strrchr(device, '/');
! 	if (cp == NULL)
! 		cp = device;
! 	else
! 		cp++;
! 	strcpy(dname, cp);
! 
! 	/*
! 	 * Split the name into a device type and a unit number.
! 	 */
! 	cp = strpbrk(dname, "0123456789");
  	if (cp == NULL) {
  		sprintf(ebuf, "%s missing unit number", device);
  		goto bad;
***************
*** 259,281 ****
  		sprintf(ebuf, "%s bad unit number", device);
  		goto bad;
  	}
  
! 	if (*device == '/')
! 		strcpy(dname, device);
! 	else
! 		sprintf(dname, "%s/%s", PCAP_DEV_PREFIX, device);
! #ifdef HAVE_DEV_DLPI
! 	/* Map network device to /dev/dlpi unit */
  	cp = "/dev/dlpi";
  	if ((p->fd = open(cp, O_RDWR)) < 0) {
  		sprintf(ebuf, "%s: %s", cp, pcap_strerror(errno));
  		goto bad;
  	}
! 	/* Map network interface to /dev/dlpi unit */
  	ppa = get_dlpi_ppa(p->fd, dname, ppa, ebuf);
  	if (ppa < 0)
  		goto bad;
  #else
  	/* Try device without unit number */
  	strcpy(dname2, dname);
  	cp = strchr(dname, *cp);
--- 270,321 ----
  		sprintf(ebuf, "%s bad unit number", device);
  		goto bad;
  	}
+ 	*cp = '\0';
  
! 	/*
! 	 * Use "/dev/dlpi" as the device.
! 	 *
! 	 * XXX - HP's DLPI Programmer's Guide for HP-UX 11.00 says that
! 	 * the "dl_mjr_num" field is for the "major number of interface
! 	 * driver"; that's the major of "/dev/dlpi" on the system on
! 	 * which I tried this, but there may be DLPI devices that
! 	 * use a different driver, in which case we may need to
! 	 * search "/dev" for the appropriate device with that major
! 	 * device number, rather than hardwiring "/dev/dlpi".
! 	 */
  	cp = "/dev/dlpi";
  	if ((p->fd = open(cp, O_RDWR)) < 0) {
  		sprintf(ebuf, "%s: %s", cp, pcap_strerror(errno));
  		goto bad;
  	}
! 
! 	/*
! 	 * Get a table of all PPAs for that device, and search that
! 	 * table for the specified device type name and unit number.
! 	 */
  	ppa = get_dlpi_ppa(p->fd, dname, ppa, ebuf);
  	if (ppa < 0)
  		goto bad;
  #else
+ 	/*
+ 	** Determine device and ppa
+ 	*/
+ 	cp = strpbrk(device, "0123456789");
+ 	if (cp == NULL) {
+ 		sprintf(ebuf, "%s missing unit number", device);
+ 		goto bad;
+ 	}
+ 	ppa = strtol(cp, &eos, 10);
+ 	if (*eos != '\0') {
+ 		sprintf(ebuf, "%s bad unit number", device);
+ 		goto bad;
+ 	}
+ 
+ 	if (*device == '/')
+ 		strcpy(dname, device);
+ 	else
+ 		sprintf(dname, "%s/%s", PCAP_DEV_PREFIX, device);
+ 
  	/* Try device without unit number */
  	strcpy(dname2, dname);
  	cp = strchr(dname, *cp);
***************
*** 391,397 ****
  		break;
  
  	default:
! 		sprintf(ebuf, "unknown mac type 0x%lu", infop->dl_mac_type);
  		goto bad;
  	}
  
--- 431,438 ----
  		break;
  
  	default:
! 		sprintf(ebuf, "unknown mac type 0x%lu",
! 		    (unsigned long)infop->dl_mac_type);
  		goto bad;
  	}
  
***************
*** 709,737 ****
  
  #ifdef DL_HP_PPA_ACK_OBS
  /*
!  * Under HP-UX 10, we can ask for the ppa
   */
  
  
! /* Determine ppa number that specifies ifname */
  static int
  get_dlpi_ppa(register int fd, register const char *device, register int unit,
      register char *ebuf)
  {
  	register dl_hp_ppa_ack_t *ap;
! 	register dl_hp_ppa_info_t *ip;
  	register int i;
  	register u_long majdev;
- 	dl_hp_ppa_req_t	req;
  	struct stat statbuf;
  	bpf_u_int32 buf[MAXDLBUF];
  
- 	if (stat(device, &statbuf) < 0) {
- 		sprintf(ebuf, "stat: %s: %s", device, pcap_strerror(errno));
- 		return (-1);
- 	}
- 	majdev = major(statbuf.st_rdev);
- 
  	memset((char *)&req, 0, sizeof(req));
  	req.dl_primitive = DL_HP_PPA_REQ;
  
--- 750,806 ----
  
  #ifdef DL_HP_PPA_ACK_OBS
  /*
!  * Under HP-UX 10 and HP-UX 11, we can ask for the ppa
   */
  
  
! /*
!  * Determine ppa number that specifies ifname.
!  *
!  * If the "dl_hp_ppa_info_t" doesn't have a "dl_module_id_1" member,
!  * the code that's used here is the old code for HP-UX 10.x.
!  *
!  * However, HP-UX 10.20, at least, appears to have such a member
!  * in its "dl_hp_ppa_info_t" structure, so the new code is used.
!  * The new code didn't work on an old 10.20 system on which Rick
!  * Jones of HP tried it, but with later patches installed, it
!  * worked - it appears that the older system had those members but
!  * didn't put anything in them, so, if the search by name fails, we
!  * do the old search.
!  *
!  * Rick suggests that making sure your system is "up on the latest
!  * lancommon/DLPI/driver patches" is probably a good idea; it'd fix
!  * that problem, as well as allowing libpcap to see packets sent
!  * from the system on which the libpcap application is being run.
!  * (On 10.20, in addition to getting the latest patches, you need
!  * to turn the kernel "lanc_outbound_promisc_flag" flag on with ADB;
!  * a posting to "comp.sys.hp.hpux" at
!  *
!  *	http://www.deja.com/[ST_rn=ps]/getdoc.xp?AN=558092266
!  *
!  * says that, to see the machine's outgoing traffic, you'd need to
!  * apply the right patches to your system, and also set that variable
!  * with:
!  
! echo 'lanc_outbound_promisc_flag/W1' | /usr/bin/adb -w /stand/vmunix /dev/kmem
! 
!  * which could be put in, for example, "/sbin/init.d/lan".
!  *
!  * Setting the variable is not necessary on HP-UX 11.x.
!  */
  static int
  get_dlpi_ppa(register int fd, register const char *device, register int unit,
      register char *ebuf)
  {
  	register dl_hp_ppa_ack_t *ap;
! 	register dl_hp_ppa_info_t *ipstart, *ip;
  	register int i;
+ 	char dname[100];
  	register u_long majdev;
  	struct stat statbuf;
+ 	dl_hp_ppa_req_t	req;
  	bpf_u_int32 buf[MAXDLBUF];
  
  	memset((char *)&req, 0, sizeof(req));
  	req.dl_primitive = DL_HP_PPA_REQ;
  
***************
*** 741,760 ****
  		return (-1);
  
  	ap = (dl_hp_ppa_ack_t *)buf;
! 	ip = (dl_hp_ppa_info_t *)((u_char *)ap + ap->dl_offset);
  
!         for(i = 0; i < ap->dl_count; i++) {
!                 if (ip->dl_mjr_num == majdev && ip->dl_instance_num == unit)
!                         break;
  
!                 ip = (dl_hp_ppa_info_t *)((u_char *)ip + ip->dl_next_offset);
!         }
          if (i == ap->dl_count) {
!                 sprintf(ebuf, "can't find PPA for %s", device);
  		return (-1);
          }
          if (ip->dl_hdw_state == HDW_DEAD) {
!                 sprintf(ebuf, "%s: hardware state: DOWN\n", device);
  		return (-1);
          }
          return ((int)ip->dl_ppa);
--- 810,887 ----
  		return (-1);
  
  	ap = (dl_hp_ppa_ack_t *)buf;
! 	ipstart = (dl_hp_ppa_info_t *)((u_char *)ap + ap->dl_offset);
! 	ip = ipstart;
  
! #ifdef HAVE_HP_PPA_INFO_T_DL_MODULE_ID_1
! 	/*
! 	 * The "dl_hp_ppa_info_t" structure has a "dl_module_id_1"
! 	 * member that should, in theory, contain the part of the
! 	 * name for the device that comes before the unit number,
! 	 * and should also have a "dl_module_id_2" member that may
! 	 * contain an alternate name (e.g., I think Ethernet devices
! 	 * have both "lan", for "lanN", and "snap", for "snapN", with
! 	 * the former being for Ethernet packets and the latter being
! 	 * for 802.3/802.2 packets).
! 	 *
! 	 * Search for the device that has the specified name and
! 	 * instance number.
! 	 */
! 	for (i = 0; i < ap->dl_count; i++) {
! 		if ((strcmp(ip->dl_module_id_1, device) == 0 ||
! 		     strcmp(ip->dl_module_id_2, device) == 0) &&
! 		    ip->dl_instance_num == unit)
! 			break;
  
! 		ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
! 	}
! #else
! 	/*
! 	 * We don't have that member, so the search is impossible; make it
! 	 * look as if the search failed.
! 	 */
! 	i = ap->dl_count;
! #endif
! 
! 	if (i == ap->dl_count) {
! 		/*
! 		 * Well, we didn't, or can't, find the device by name.
! 		 *
! 		 * HP-UX 10.20, whilst it has "dl_module_id_1" and
! 		 * "dl_module_id_2" fields in the "dl_hp_ppa_info_t",
! 		 * doesn't seem to fill them in unless the system is
! 		 * at a reasonably up-to-date patch level.
! 		 *
! 		 * Older HP-UX 10.x systems might not have those fields
! 		 * at all.
! 		 *
! 		 * Therefore, we'll search for the entry with the major
! 		 * device number of a device with the name "/dev/<dev><unit>",
! 		 * if such a device exists, as the old code did.
! 		 */
! 		sprintf(dname, "/dev/%s%d", device, unit);
! 		if (stat(dname, &statbuf) < 0) {
! 			sprintf(ebuf, "stat: %s: %s", dname, pcap_strerror(errno));
! 			return (-1);
! 		}
! 		majdev = major(statbuf.st_rdev);
! 
! 		ip = ipstart;
! 
! 		for (i = 0; i < ap->dl_count; i++) {
! 			if (ip->dl_mjr_num == majdev &&
! 			    ip->dl_instance_num == unit)
! 				break;
! 
! 			ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
! 		}
! 	}
          if (i == ap->dl_count) {
!                 sprintf(ebuf, "can't find /dev/dlpi PPA for %s%d", device, unit);
  		return (-1);
          }
          if (ip->dl_hdw_state == HDW_DEAD) {
!                 sprintf(ebuf, "%s%d: hardware state: DOWN\n", device, unit);
  		return (-1);
          }
          return ((int)ip->dl_ppa);
***************
*** 783,789 ****
  	register int kd;
  	void *addr;
  	struct ifnet ifnet;
! 	char if_name[sizeof(ifnet.if_name)], tifname[32];
  
  	cp = strrchr(ifname, '/');
  	if (cp != NULL)
--- 910,916 ----
  	register int kd;
  	void *addr;
  	struct ifnet ifnet;
! 	char if_name[sizeof(ifnet.if_name) + 1];
  
  	cp = strrchr(ifname, '/');
  	if (cp != NULL)
***************
*** 811,823 ****
  		if (dlpi_kread(kd, (off_t)addr,
  		    &ifnet, sizeof(ifnet), ebuf) < 0 ||
  		    dlpi_kread(kd, (off_t)ifnet.if_name,
! 		    if_name, sizeof(if_name), ebuf) < 0) {
  			(void)close(kd);
  			return (-1);
  		}
! 		sprintf(tifname, "%.*s%d",
! 		    (int)sizeof(if_name), if_name, ifnet.if_unit);
! 		if (strcmp(tifname, ifname) == 0)
  			return (ifnet.if_index);
  	}
  
--- 938,949 ----
  		if (dlpi_kread(kd, (off_t)addr,
  		    &ifnet, sizeof(ifnet), ebuf) < 0 ||
  		    dlpi_kread(kd, (off_t)ifnet.if_name,
! 		    if_name, sizeof(ifnet.if_name), ebuf) < 0) {
  			(void)close(kd);
  			return (-1);
  		}
! 		if_name[sizeof(ifnet.if_name)] = '\0';
! 		if (strcmp(if_name, ifname) == 0 && ifnet.if_unit == unit)
  			return (ifnet.if_index);
  	}
  
