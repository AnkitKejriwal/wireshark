## Makefile for building ethereal.exe with Microsoft C and nmake
## Use: $(MAKE) /$(MAKEFLAGS) -f makefile.nmake
#
# $Id: Makefile.nmake,v 1.46 2004/07/07 16:23:12 ulfl Exp $

include ..\config.nmake
include <win32.mak>
include Makefile.common


############### no need to modify below this line #########

CFLAGS=-DHAVE_CONFIG_H /I. /I.. /I../wiretap $(GLIB_CFLAGS) \
	$(ZLIB_CFLAGS) $(ADNS_CFLAGS) $(PCRE_CFLAGS) /I$(PCAP_DIR)\include \
	-D_U_="" $(LOCAL_CFLAGS)

CVARSDLL=-DWIN32 -DNULL=0 -D_MT -D_DLL

# For use when making libethereal.dll
libethereal_LIBS = \
	$(GLIB_LIBS)	\
	$(ADNS_LIBS) \
	$(PCRE_LIBS) \
	$(ZLIB_LIBS) \
	$(NET_SNMP_DIR)\win32\lib\netsnmp.lib \
	ftypes\ftypes.lib \
	dfilter\dfilter.lib \
	..\dissectors.lib

.c.obj::
	$(CC) $(CVARSDLL) $(CFLAGS) -Fd.\ -c $<

OBJECTS=addr_and_mask.obj \
	atalk-utils.obj	\
	bitswap.obj	\
	circuit.obj     \
	column-utils.obj \
	conversation.obj \
	epan.obj         \
	except.obj       \
	filesystem.obj   \
	frame_data.obj	\
	inet_aton.obj	\
	inet_pton.obj	\
	inet_ntop.obj	\
	ipv4.obj         \
	int-64bit.obj	\
	osi-utils.obj	\
	packet.obj       \
	plugins.obj      \
	proto.obj        \
	register.obj \
	resolv.obj       \
	sna-utils.obj	\
	strutil.obj      \
	timestamp.obj \
	to_str.obj	\
	tvbuff.obj       \
	value_string.obj

!IFDEF ENABLE_LIBETHEREAL
all: ftypes dfilter libethereal.dll
!ELSE
all: ftypes dfilter ethereal.lib
!ENDIF

# For use when making libethereal.dll
libethereal.lib: libethereal.dll
libethereal.exp: libethereal.dll

libethereal.dll: ..\config.h $(OBJECTS) libethereal.def ftypes dfilter doxygen ..\image\libethereal.res
	$(link) $(dlllflags) $(conlibsdll) \
		$(LOCAL_LDFLAGS) \
		/DEF:libethereal.def /OUT:libethereal.dll \
		/IMPLIB:libethereal.lib $(OBJECTS) $(libethereal_LIBS) \
		..\image\libethereal.res \
		

ethereal.lib	: ..\config.h $(OBJECTS)
	link /lib /out:ethereal.lib $(OBJECTS)

..\config.h	: ..\config.h.win32 ..\config.nmake
	cd ..
	$(MAKE) -f Makefile.nmake config.h
	cd epan

clean:
	rm -f $(OBJECTS) ethereal.lib libethereal.dll libethereal.lib libethereal.exp $(PDB_FILE) doxygen.cfg html/*.*
    if exist html rmdir html	
	cd ftypes
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake clean
	cd ../dfilter
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake clean
	cd ..

distclean: clean
	rm -f config.h register.c
	cd ftypes
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake distclean
	cd ../dfilter
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake distclean
	cd ..

ftypes:: ..\config.h
	cd ftypes
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake
	cd ..

dfilter:: ..\config.h
	cd dfilter
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake
	cd ..

doxygen.cfg: ..\config.nmake doxygen.cfg.in
	sed -e s/@VERSION@/$(VERSION)/ \
	    < doxygen.cfg.in > $@

doxygen-run:
!IFDEF DOXYGEN
	$(DOXYGEN) doxygen.cfg
!ENDIF

doxygen: doxygen.cfg doxygen-run

#
# Build "register.c", which contains a function "register_all_protocols()"
# that calls the register routines for all protocols.
#
# We do this by grepping through sources.  If that turns out to be too slow,
# maybe we could just require every .o file to have an register routine
# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
#
# Formatting conventions:  The name of the proto_register_* routines must
# start in column zero, or must be preceded only by "void " starting in
# column zero, and must not be inside #if.
#
# We assume that all dissector routines are in "packet-XXX.c" files.
#
# For some unknown reason, having a big "for" loop in the Makefile
# to scan all the "packet-XXX.c" files doesn't work with some "make"s;
# they seem to pass only the first few names in the list to the shell,
# for some reason.
#
# Therefore, we have a script to generate the "register.c" file.
#
# The first argument is the name of the file to write.
# The second argument is the directory in which the source files live.
# All subsequent arguments are the files to scan.
#
# On Windows, however, that script runs slowly, as multiple greps
# and seds are run for each input file, so, if Python is present
# (as indicated by PYTHON being defined), we run a faster Python
# script to do that work instead.  That script doesn't take the name
# of the file to write as an argument; it always writes to
# "register.c".
#
register.c: $(DISSECTOR_SRC)
!IFDEF PYTHON
	@echo Making register.c (using python)
	@$(PYTHON) ..\make-reg-dotc.py . $(DISSECTOR_SRC)
!ELSE
	@echo Making register.c (using sh)
	@$(SH) ../make-reg-dotc register.c . $(DISSECTOR_SRC)
!ENDIF
