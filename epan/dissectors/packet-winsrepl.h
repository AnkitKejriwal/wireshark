/* header auto-generated by pidl */

/*
 * winsrepl.h (generated from winsrepl.idl)
 *
 * Modified for ethereal:
 *
 * uint8_t			=> guint8
 * uint16_t			=> guint16
 * uint32_t			=> guint32
 * uint64_t			=> guint64
 * ipv4addres (const char *)	=> address
 * DATA_BLOB			=> (skipped)
 */

#ifndef _HEADER_wrepl
#define _HEADER_wrepl

#define WINS_REPLICATION_PORT	( 42 )
#define WREPL_OPCODE_BITS	( 0x7800 )
struct wrepl_ip {
	address owner;
	address ip;
}/* [flag(LIBNDR_FLAG_BIGENDIAN)] */;

struct wrepl_address_list {
	guint32 num_ips;
	struct wrepl_ip *ips;
}/* [flag(LIBNDR_FLAG_LITTLE_ENDIAN)] */;

union wrepl_addresses {
	address ip;/* [case(0)] */
	struct wrepl_address_list addresses;/* [case(2)] */
}/* [nodiscriminant] */;

struct wrepl_wins_name {
	guint32 name_len;
	guint8 *name;
	guint32 flags;
	guint32 group_flag;/* [flag(LIBNDR_FLAG_LITTLE_ENDIAN)] */
	guint64 id;
	union wrepl_addresses addresses;/* [switch_is(flags&2)] */
	address unknown;
};

struct wrepl_send_reply {
	guint32 num_names;
	struct wrepl_wins_name *names;
};

struct wrepl_wins_owner {
	address address;
	guint64 max_version;
	guint64 min_version;
	guint32 type;
};

struct wrepl_table {
	guint32 partner_count;
	struct wrepl_wins_owner *partners;
	address initiator;
};

enum wrepl_replication_cmd {
	WREPL_REPL_TABLE_QUERY=0,
	WREPL_REPL_TABLE_REPLY=1,
	WREPL_REPL_SEND_REQUEST=2,
	WREPL_REPL_SEND_REPLY=3,
	WREPL_REPL_UPDATE=4,
	WREPL_REPL_5=5,
	WREPL_REPL_INFORM=8,
	WREPL_REPL_9=9
};

union wrepl_replication_info {
	struct wrepl_table table;/* [case(WREPL_REPL_TABLE_REPLY)] */
	struct wrepl_wins_owner owner;/* [case(WREPL_REPL_SEND_REQUEST)] */
	struct wrepl_send_reply reply;/* [case(WREPL_REPL_SEND_REPLY)] */
}/* [nodiscriminant] */;

struct wrepl_replication {
	enum wrepl_replication_cmd command;
	union wrepl_replication_info info;/* [switch_is(command)] */
};

struct wrepl_start {
	guint32 assoc_ctx;
	guint16 minor_version;
	guint16 major_version;
};

struct wrepl_stop {
	guint32 reason;
};

enum wrepl_mess_type {
	WREPL_START_ASSOCIATION=0,
	WREPL_START_ASSOCIATION_REPLY=1,
	WREPL_STOP_ASSOCIATION=2,
	WREPL_REPLICATION=3
};

union wrepl_message {
	struct wrepl_start start;/* [case(WREPL_START_ASSOCIATION)] */
	struct wrepl_start start_reply;/* [case(WREPL_START_ASSOCIATION_REPLY)] */
	struct wrepl_stop stop;/* [case(WREPL_STOP_ASSOCIATION)] */
	struct wrepl_replication replication;/* [case(WREPL_REPLICATION)] */
}/* [nodiscriminant] */;

struct wrepl_packet {
	guint32 opcode;
	guint32 assoc_ctx;
	enum wrepl_mess_type mess_type;
	union wrepl_message message;/* [switch_is(mess_type)] */
	/*DATA_BLOB padding;*//* [flag(LIBNDR_FLAG_REMAINING)] */
}/* [gensize,public,flag(LIBNDR_FLAG_BIGENDIAN|LIBNDR_PRINT_ARRAY_HEX)] */;

struct wrepl_wrap {
	guint32 size;/* [value(ndr_size_wrepl_packet(&packet,ndr->flags))] */
	struct wrepl_packet packet;
}/* [public,flag(LIBNDR_FLAG_BIGENDIAN|LIBNDR_PRINT_ARRAY_HEX)] */;


struct decode_winsrepl {
	struct {
		struct wrepl_wrap p;
	} in;

};

#endif /* _HEADER_wrepl */
